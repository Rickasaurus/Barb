{"body":"Barb is a small dynamic scripting language for .NET with the following properties:\r\n\r\n- Syntax that makes both F# and C# devs feel at home\r\n- Fully expression oriented (Whitespace is completely ignored)\r\n- Paren based scoping rules (Lisp-like)\r\n- Pure functional (No mutation allowed)\r\n\r\nThis makes Barb an easy to learn language which you can give to your users for safely scripting over data in your application.  Best of all, you'll be able to use it without learning a bunch of new syntax.\r\n\r\n\r\nWhy Barb?\r\n---------\r\n\r\nI created Barb because I needed a user language for my applications but yet no existing .NET language both hosted nicely inside of my application and met my criteria:\r\n\r\n- Simple/Terse Syntax\r\n- Expression Oriented (Any program should be able to be represented in a single line of code)\r\n- No casting necessary and transparent type conversions\r\n- Native .NET type system (No painful conversions!)\r\n- Tries really hard to do what a non-technical user would expect\r\n- Fast Execution (I use it to script over sets of records in the millions range)\r\n- Safe from accidental data corruption by non-technical users\r\n\r\nDynamic Linq, IronPython and IronRuby all failed for one of these reasons or another.\r\n\r\nThe current implementation is still young and a bit rough around the edges. It's was originally designed for writing one-line expressions along these lines:\r\n\r\n\t(Name.Contains \"John\" or Name.Contains \"Mary\") and (Age > 20 or Weight > 200)\r\n\r\nIt can do much more now, but still needs work to be friendly enoungh for a real release. In particular, it needs better error messages and a friendly API for hosting. However, I thought it might be useful to others in its current form.  If you do play with it I hope you'll let me know what you think.\r\n\r\n\r\nCurrent Features <a id=\"features\" />\r\n----------------\r\n\r\n- Recursive lambda bindings with F# or C# syntax\r\n- Value name binding with F# or C# syntax\r\n- Order of operations \r\n- Static or instance calls and indexers via cached reflection\r\n- Numerical sequence expressions (Identical to F#'s)\r\n- Tuples (any IEnumerable is treated as a tuple internally)\r\n\r\n\r\nPlanned Limitations <a id=\"limitations\" />\r\n-------------------\r\n\r\n- All numbers are converted internally to Int64 or Double.  This will change but was necessary for now to keep things simple.\r\n- Barb may cause unexpected behavior when making calls that mutate things.  There is a settings option which fixes this, but it tones down optimization significantly.\r\n\r\n\r\nThings To Do <a id=\"todo\" />\r\n------------\r\n\r\n- Lambda interop with .NET\r\n- Extension method resolution\r\n- Generalized Sequence Expressions\r\n- Better Looping Constructs\r\n- Pattern Matching\r\n- Optimized Numeric Type Handling\r\n\r\n\r\nExamples of Use <a id=\"examples\" />\r\n---------------\r\n\r\nThe best way to think about Barb is over some collection of records (data classes to you C# folks).\r\n\r\n\ttype CustRecord =\r\n\t\t{\r\n\t\t\tName: string\r\n\t\t\tAge: int\r\n\t\t\tWeight: int\r\n\t\t\tSource: obj\r\n\t\t\tLocations: string array\r\n\t\t}\r\n\r\n#### As mentioned above, Barb is great for writing queries. ####\r\n\r\nIn Barb you can choose either the words \"and\"/\"or\" or use \"&&\"/\"||\", whichever makes you more comfortable.\r\n\r\n\tlet predicate = buildExpr<CustRecord,bool>(\"Name.Contains 'John' and (Age > 20 or Weight > 200)\")\r\n\r\nThis will will return a predicate which you can then use to filter over large numbers of records.\r\n\r\n#### It can also be used to for user specified reflection. ####\r\n\r\nOne case where I use this is for writing out CSV files. Given a set of record field specifying strings, you can easily build functions which will grab the specified data.  \r\n \r\n\tlet fld1Getter = buildExpr<CustRecord,int>(\"Weight\") \r\n\r\nQuite simple right? Barb will also convert to the correct output type if able.\r\n \r\n\tlet fld1Getter = buildExpr<CustRecord,string>(\"Weight\") \r\n\r\nHere the integer will be converted on the fly to string because it's what you statically specified.\r\n \r\n\tlet fld1Getter = buildExpr<CustRecord,string>(\"Source.Url\")\r\n\r\nBarb can will also reflect into the real type of a given obj, which can be quite handy for taking the hard work out of accessing untyped data.\r\n\r\n\r\n#### Barb supports many of the constructs a F# user would expect ####\r\n\r\n\tbuildExpr<CustRecord,string>(\"Locations.[0]\") // The F# style '.' is optional :)\r\n\tbuildExpr<CustRecord,string>(\"if Age > 40 then 'Old' else 'Young'\")\r\n\tbuildExpr<CustRecord,int>(\"let x = Age + 1 in x\") // or..\r\n\tbuildExpr<CustRecord,int>(\"var x = Age + 1 in x\") // (although, I may use var for mutables in the future)\r\n\r\n...and some fancier ones from F#\r\n\r\n\tbuildExpr<unit,seq<int>>(\"{ 1 .. 5 }\") // Returns 1,2,3,4,5\r\n\tbuildExpr<unit,seq<int>>(\"{ 1 .. 2 .. 10 }\") // Returns 1,3,5,7,9\r\n\tbuildExpr<unit,seq<int>>(\"(1, 2, 3)\") // Returns 1,2,3\r\n\r\n...all looping must currently be handled with lambda recursion\r\n\r\n\tbuildExpr<unit,seq<int>>(\"let recfun = fun x -> if x > 1 then x else recfun (x + 1) in recfun 0\") \r\n\r\n...but it's still growing and more features are being added all the time.\r\n\r\nLanguage Details <a id=\"details\" />\r\n----------------\r\n\r\n#### Subexpression Forms ####\r\n\t\r\n\tSubscope: \t\t( <code> )\r\n\tTuple: \t\t\t... <code>, <code>, <code> ...\r\n\tLambda (F#): \tfun <binding> -> <code> ...\r\n\tLambda (C#): \t<binding> => <code> ...\r\n\tBranching:\t\tif <code> then <code> else <code> ...\r\n\tIndexing:\t\t<obj>[ <code> ]\r\n\tBinding (F#):\tlet <name> = <code> in\r\n\tBinding (C#):\tvar <name> = <code> in\r\n\t\r\nNote that '...' indicates an unbounded expression.  It can be bounded by a parent expression or explicitly by using a subscope.\r\n\r\n#### Operators and Keywords\r\n\r\n\t(): \t\t\tUnit\r\n\tnew <name>:\t\tCreates a new .NET instance of Class \"name\"\r\n\tnull: \t\t\tCreates a null instance\r\n\ttrue:\t\t\tCreates a boolean of value true\r\n\tfalse:\t\t\tCreates a boolean of value false\r\n\t== or =:\t\tEquals Operator\r\n\t<> or !=:\t\tNot-Equals Operator\r\n\t>:\t\t\t\tGreater than\r\n\t>=:\t\t\t\tGreater than or equal to\r\n\t<:\t\t\t\tLess than\r\n\t<=:\t\t\t\tLess than or equal to\r\n\t! or not:\t\tInvert Boolean\r\n\t&, && or and:\tBoolean And\r\n\t|, || or or:\tBoolean Or\r\n\t/:\t\t\t\tArithmetic Divide\r\n\t*:\t\t\t\tArithmetic Multiply\r\n\t+:\t\t\t\tArithmetic Add\r\n\t-:\t\t\t\tArithmetic Subtract\r\n\t\\/:\t\t\t\tSet Union\r\n\t/\\:\t\t\t\tSet Intersection\r\n\t/?\\:\t\t\tSet Has Intersection\r\n\r\nExtra Nerdy Stuff Under Here <a id=\"nerdy\" />\r\n----------------------------\r\n\r\nCompilation is done by n-tuple merging of expression nodes.  This is done initially to pre-compute as much as possible and the optimized result is then reduced again with the information given by the passed in data object.  Decisions can be made at runtime based on the contents of these tuples and their neighbors.  This allows for a huge amount of flexibility in deciding what to do.  Function/Value composition also allows for fast code to be built out of existing .NET constructs and eliminates the complexity of a intermediate representation.\r\n\r\nIt's kind of Scheme-like under the hood, but I've worked hard to make it very C#/F#ish on the surface.","google":"UA-33324690-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Barb","tagline":"A Simple Dynamic Scripting Language for .NET"}